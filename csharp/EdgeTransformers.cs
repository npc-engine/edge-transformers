// Automatically generated by Interoptopus.

#pragma warning disable 0105
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using EdgeTransformers;
#pragma warning restore 0105

namespace EdgeTransformers
{
    public static partial class Interop
    {
        public const string NativeLib = "edge_transformers";

        static Interop()
        {
        }


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_env_destroy")]
        public static extern FFIError onnx_env_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_env_new")]
        public static extern FFIError onnx_env_new(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_string_batch_destroy")]
        public static extern FFIError onnx_string_batch_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_string_batch_new")]
        public static extern FFIError onnx_string_batch_new(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_string_batch_add")]
        public static extern FFIError onnx_string_batch_add(IntPtr context, string add_string);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_string_batch_get")]
        public static extern IntPtr onnx_string_batch_get(IntPtr context, uint id);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_string_batch_length")]
        public static extern uint onnx_string_batch_length(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_string_batch_clear")]
        public static extern FFIError onnx_string_batch_clear(IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_destroy")]
        public static extern FFIError onnx_cond_gen_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_from_pretrained")]
        public static extern FFIError onnx_cond_gen_from_pretrained(ref IntPtr context, IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_create_from_memory")]
        public static extern FFIError onnx_cond_gen_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_create_from_files")]
        public static extern FFIError onnx_cond_gen_create_from_files(ref IntPtr context, IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_generate_topk_sampling")]
        public static extern IntPtr onnx_cond_gen_generate_topk_sampling(IntPtr context, string input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_generate_random_sampling")]
        public static extern IntPtr onnx_cond_gen_generate_random_sampling(IntPtr context, string input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_generate_argmax")]
        public static extern IntPtr onnx_cond_gen_generate_argmax(IntPtr context, string input, int max_length);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_generate_topk_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_cond_gen_generate_topk_sampling_batch(IntPtr s, IntPtr input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_generate_random_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_cond_gen_generate_random_sampling_batch(IntPtr s, IntPtr input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_generate_argmax_batch")]
        public static extern SliceUseAsciiStringPattern onnx_cond_gen_generate_argmax_batch(IntPtr s, IntPtr input, int max_length);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_destroy")]
        public static extern FFIError onnx_cond_gen_pkvs_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_from_pretrained")]
        public static extern FFIError onnx_cond_gen_pkvs_from_pretrained(ref IntPtr context, IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_create_from_memory")]
        public static extern FFIError onnx_cond_gen_pkvs_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_create_from_paths")]
        public static extern FFIError onnx_cond_gen_pkvs_create_from_paths(ref IntPtr context, IntPtr env, string model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_generate_topk_sampling")]
        public static extern IntPtr onnx_cond_gen_pkvs_generate_topk_sampling(IntPtr context, string input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_generate_random_sampling")]
        public static extern IntPtr onnx_cond_gen_pkvs_generate_random_sampling(IntPtr context, string input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_generate_argmax")]
        public static extern IntPtr onnx_cond_gen_pkvs_generate_argmax(IntPtr context, string input, int max_length);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_generate_topk_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_cond_gen_pkvs_generate_topk_sampling_batch(IntPtr s, IntPtr input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_generate_random_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_cond_gen_pkvs_generate_random_sampling_batch(IntPtr s, IntPtr input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_cond_gen_pkvs_generate_argmax_batch")]
        public static extern SliceUseAsciiStringPattern onnx_cond_gen_pkvs_generate_argmax_batch(IntPtr s, IntPtr input, int max_length);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_emb_destroy")]
        public static extern FFIError onnx_emb_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_emb_from_pretrained")]
        public static extern FFIError onnx_emb_from_pretrained(ref IntPtr context, IntPtr env, string model_id, PoolingStrategyFFI pooling_strategy, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_emb_create_from_memory")]
        public static extern FFIError onnx_emb_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, PoolingStrategyFFI pooling_strategy, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_emb_create_from_files")]
        public static extern FFIError onnx_emb_create_from_files(ref IntPtr context, IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, PoolingStrategyFFI pooling_strategy, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_emb_embed")]
        public static extern EmbeddingFFI onnx_emb_embed(IntPtr s, string input);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_emb_embed_batch")]
        public static extern SliceEmbeddingFFI onnx_emb_embed_batch(IntPtr s, IntPtr input);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_classification_destroy")]
        public static extern FFIError onnx_classification_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_classification_from_pretrained")]
        public static extern FFIError onnx_classification_from_pretrained(ref IntPtr context, IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_classification_create_from_memory")]
        public static extern FFIError onnx_classification_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_classification_create_from_files")]
        public static extern FFIError onnx_classification_create_from_files(ref IntPtr context, IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_classification_classify")]
        public static extern PredictionFFI onnx_classification_classify(IntPtr s, string input);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_classification_classify_batch")]
        public static extern SlicePredictionFFI onnx_classification_classify_batch(IntPtr s, IntPtr input);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_token_classification_destroy")]
        public static extern FFIError onnx_token_classification_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_token_classification_from_pretrained")]
        public static extern FFIError onnx_token_classification_from_pretrained(ref IntPtr context, IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_token_classification_create_from_memory")]
        public static extern FFIError onnx_token_classification_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_token_classification_create_from_files")]
        public static extern FFIError onnx_token_classification_create_from_files(ref IntPtr context, IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_token_classification_tag")]
        public static extern TaggedStringFFI onnx_token_classification_tag(IntPtr s, string input);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_token_classification_tag_batch")]
        public static extern SliceTaggedStringFFI onnx_token_classification_tag_batch(IntPtr s, IntPtr input);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_destroy")]
        public static extern FFIError onnx_optimum_seq2seq_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_from_pretrained")]
        public static extern FFIError onnx_optimum_seq2seq_from_pretrained(ref IntPtr context, IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_create_from_memory")]
        public static extern FFIError onnx_optimum_seq2seq_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 encoder_model, Sliceu8 decoder_model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_create_from_files")]
        public static extern FFIError onnx_optimum_seq2seq_create_from_files(ref IntPtr context, IntPtr env, string encoder_model_path, string decoder_model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_generate_topk_sampling")]
        public static extern IntPtr onnx_optimum_seq2seq_generate_topk_sampling(IntPtr context, string input, Option*const i8 decoder_input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_generate_random_sampling")]
        public static extern IntPtr onnx_optimum_seq2seq_generate_random_sampling(IntPtr context, string input, Option*const i8 decoder_input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_generate_argmax")]
        public static extern IntPtr onnx_optimum_seq2seq_generate_argmax(IntPtr context, string input, Option*const i8 decoder_input, int max_length);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_generate_topk_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_optimum_seq2seq_generate_topk_sampling_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_generate_random_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_optimum_seq2seq_generate_random_sampling_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_generate_argmax_batch")]
        public static extern SliceUseAsciiStringPattern onnx_optimum_seq2seq_generate_argmax_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_destroy")]
        public static extern FFIError onnx_optimum_seq2seq_pkvs_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_from_pretrained")]
        public static extern FFIError onnx_optimum_seq2seq_pkvs_from_pretrained(ref IntPtr context, IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_create_from_memory")]
        public static extern FFIError onnx_optimum_seq2seq_pkvs_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 encoder_model, Sliceu8 decoder_model, Sliceu8 decoder_model_pkvs, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization_level);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_create_from_files")]
        public static extern FFIError onnx_optimum_seq2seq_pkvs_create_from_files(ref IntPtr context, IntPtr env, string encoder_model_path, string decoder_model_path, string decoder_model_pkvs_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization_level);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_generate_topk_sampling")]
        public static extern IntPtr onnx_optimum_seq2seq_pkvs_generate_topk_sampling(IntPtr context, string input, Option*const i8 decoder_input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_generate_random_sampling")]
        public static extern IntPtr onnx_optimum_seq2seq_pkvs_generate_random_sampling(IntPtr context, string input, Option*const i8 decoder_input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_generate_argmax")]
        public static extern IntPtr onnx_optimum_seq2seq_pkvs_generate_argmax(IntPtr context, string input, Option*const i8 decoder_input, int max_length);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_generate_topk_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_optimum_seq2seq_pkvs_generate_topk_sampling_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_generate_random_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_optimum_seq2seq_pkvs_generate_random_sampling_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_optimum_seq2seq_pkvs_generate_argmax_batch")]
        public static extern SliceUseAsciiStringPattern onnx_optimum_seq2seq_pkvs_generate_argmax_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_destroy")]
        public static extern FFIError onnx_seq2seq_destroy(ref IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_from_pretrained")]
        public static extern FFIError onnx_seq2seq_from_pretrained(ref IntPtr context, IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_create_from_memory")]
        public static extern FFIError onnx_seq2seq_create_from_memory(ref IntPtr context, IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_create_from_files")]
        public static extern FFIError onnx_seq2seq_create_from_files(ref IntPtr context, IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_generate_topk_sampling")]
        public static extern IntPtr onnx_seq2seq_generate_topk_sampling(IntPtr context, string input, Option*const i8 decoder_input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_generate_random_sampling")]
        public static extern IntPtr onnx_seq2seq_generate_random_sampling(IntPtr context, string input, Option*const i8 decoder_input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_generate_argmax")]
        public static extern IntPtr onnx_seq2seq_generate_argmax(IntPtr context, string input, Option*const i8 decoder_input, int max_length);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_generate_topk_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_seq2seq_generate_topk_sampling_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length, int topk, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_generate_random_sampling_batch")]
        public static extern SliceUseAsciiStringPattern onnx_seq2seq_generate_random_sampling_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length, float temperature);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "onnx_seq2seq_generate_argmax_batch")]
        public static extern SliceUseAsciiStringPattern onnx_seq2seq_generate_argmax_batch(IntPtr s, IntPtr input, OptionStringBatch decoder_input, int max_length);

    }

    public enum DeviceFFI
    {
        CPU = 0,
        DML = 1,
    }

    public enum GraphOptimizationLevelFFI
    {
        DisableAll = 0,
        Basic = 1,
        Extended = 2,
        All = 99,
    }

    public enum PoolingStrategyFFI
    {
        Mean = 0,
        Max = 1,
        First = 2,
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct ClassPredictionFFI
    {
        public string label;
        public float score;
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct EmbeddingFFI
    {
        public Slicef32 embedding;
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PredictionFFI
    {
        public ClassPredictionFFI best;
        public SliceClassPredictionFFI all;
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct TaggedStringFFI
    {
        public string input_string;
        public SliceTokenClassPredictionFFI tags;
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct TokenClassPredictionFFI
    {
        public ClassPredictionFFI best;
        public SliceClassPredictionFFI all;
        public uint start;
        public uint end;
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct UseAsciiStringPattern
    {
        public string ascii_string;
    }

    public enum FFIError
    {
        Ok = 0,
        Null = 100,
        Panic = 200,
        Fail = 300,
    }

    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SliceClassPredictionFFI
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct SliceClassPredictionFFI : IEnumerable<ClassPredictionFFI>
    {
        public SliceClassPredictionFFI(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceClassPredictionFFI(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public ClassPredictionFFI this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(ClassPredictionFFI));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<ClassPredictionFFI>(ptr);
            }
        }
        public ClassPredictionFFI[] Copied
        {
            get
            {
                var rval = new ClassPredictionFFI[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<ClassPredictionFFI> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SliceEmbeddingFFI
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct SliceEmbeddingFFI : IEnumerable<EmbeddingFFI>
    {
        public SliceEmbeddingFFI(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceEmbeddingFFI(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public EmbeddingFFI this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(EmbeddingFFI));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<EmbeddingFFI>(ptr);
            }
        }
        public EmbeddingFFI[] Copied
        {
            get
            {
                var rval = new EmbeddingFFI[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<EmbeddingFFI> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SlicePredictionFFI
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct SlicePredictionFFI : IEnumerable<PredictionFFI>
    {
        public SlicePredictionFFI(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SlicePredictionFFI(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public PredictionFFI this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(PredictionFFI));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<PredictionFFI>(ptr);
            }
        }
        public PredictionFFI[] Copied
        {
            get
            {
                var rval = new PredictionFFI[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<PredictionFFI> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SliceTaggedStringFFI
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct SliceTaggedStringFFI : IEnumerable<TaggedStringFFI>
    {
        public SliceTaggedStringFFI(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceTaggedStringFFI(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public TaggedStringFFI this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(TaggedStringFFI));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<TaggedStringFFI>(ptr);
            }
        }
        public TaggedStringFFI[] Copied
        {
            get
            {
                var rval = new TaggedStringFFI[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<TaggedStringFFI> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SliceTokenClassPredictionFFI
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct SliceTokenClassPredictionFFI : IEnumerable<TokenClassPredictionFFI>
    {
        public SliceTokenClassPredictionFFI(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceTokenClassPredictionFFI(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public TokenClassPredictionFFI this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(TokenClassPredictionFFI));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<TokenClassPredictionFFI>(ptr);
            }
        }
        public TokenClassPredictionFFI[] Copied
        {
            get
            {
                var rval = new TokenClassPredictionFFI[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<TokenClassPredictionFFI> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SliceUseAsciiStringPattern
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct SliceUseAsciiStringPattern : IEnumerable<UseAsciiStringPattern>
    {
        public SliceUseAsciiStringPattern(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceUseAsciiStringPattern(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public UseAsciiStringPattern this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(UseAsciiStringPattern));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<UseAsciiStringPattern>(ptr);
            }
        }
        public UseAsciiStringPattern[] Copied
        {
            get
            {
                var rval = new UseAsciiStringPattern[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<UseAsciiStringPattern> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Slicef32
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct Slicef32 : IEnumerable<float>
    {
        public Slicef32(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public Slicef32(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public float this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(float));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<float>(ptr);
            }
        }
        public float[] Copied
        {
            get
            {
                var rval = new float[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<float> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Sliceu8
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct Sliceu8 : IEnumerable<byte>
    {
        public Sliceu8(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public Sliceu8(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        public byte this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                var size = Marshal.SizeOf(typeof(byte));
                var ptr = new IntPtr(data.ToInt64() + i * size);
                return Marshal.PtrToStructure<byte>(ptr);
            }
        }
        public byte[] Copied
        {
            get
            {
                var rval = new byte[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Option*const i8
    {
        ///Element that is maybe valid.
        string t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct Option*const i8
    {
        public static Option*const i8 FromNullable(IntPtr? nullable)
        {
            var result = new Option*const i8();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public IntPtr? ToNullable()
        {
            return this.is_some == 1 ? this.t : (IntPtr?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionStringBatch
    {
        ///Element that is maybe valid.
        IntPtr t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionStringBatch
    {
        public static OptionStringBatch FromNullable(IntPtr? nullable)
        {
            var result = new OptionStringBatch();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public IntPtr? ToNullable()
        {
            return this.is_some == 1 ? this.t : (IntPtr?)null;
        }
    }



    /// Holds text embedding with model specific threshold for cosine similarity.
    public partial class Environment : IDisposable
    {
        private IntPtr _context;

        private Environment() {}

        public static Environment New()
        {
            var self = new Environment();
            var rval = Interop.onnx_env_new(ref self._context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_env_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public IntPtr Context => _context;
    }


    public partial class StringBatch : IDisposable
    {
        private IntPtr _context;

        private StringBatch() {}

        public static StringBatch New()
        {
            var self = new StringBatch();
            var rval = Interop.onnx_string_batch_new(ref self._context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_string_batch_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void Add(string add_string)
        {
            var rval = Interop.onnx_string_batch_add(_context, add_string);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public string Get(uint id)
        {
            var s = Interop.onnx_string_batch_get(_context, id);
            return Marshal.PtrToStringAnsi(s);
        }

        public uint Length()
        {
            return Interop.onnx_string_batch_length(_context);
        }

        public void Clear()
        {
            var rval = Interop.onnx_string_batch_clear(_context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public IntPtr Context => _context;
    }


    public partial class ConditionalGenerationPipeline : IDisposable
    {
        private IntPtr _context;

        private ConditionalGenerationPipeline() {}

        public static ConditionalGenerationPipeline FromPretrained(IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new ConditionalGenerationPipeline();
            var rval = Interop.onnx_cond_gen_from_pretrained(ref self._context, env, model_id, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static ConditionalGenerationPipeline CreateFromMemory(IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new ConditionalGenerationPipeline();
            var rval = Interop.onnx_cond_gen_create_from_memory(ref self._context, env, model, tokenizer_config, special_tokens_map, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static ConditionalGenerationPipeline CreateFromFiles(IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new ConditionalGenerationPipeline();
            var rval = Interop.onnx_cond_gen_create_from_files(ref self._context, env, model_path, tokenizer_config_path, special_tokens_map_path, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_cond_gen_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public string GenerateTopkSampling(string input, int max_length, int topk, float temperature)
        {
            var s = Interop.onnx_cond_gen_generate_topk_sampling(_context, input, max_length, topk, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateRandomSampling(string input, int max_length, float temperature)
        {
            var s = Interop.onnx_cond_gen_generate_random_sampling(_context, input, max_length, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateArgmax(string input, int max_length)
        {
            var s = Interop.onnx_cond_gen_generate_argmax(_context, input, max_length);
            return Marshal.PtrToStringAnsi(s);
        }

        public SliceUseAsciiStringPattern GenerateTopkSamplingBatch(IntPtr input, int max_length, int topk, float temperature)
        {
            return Interop.onnx_cond_gen_generate_topk_sampling_batch(_context, input, max_length, topk, temperature);
        }

        public SliceUseAsciiStringPattern GenerateRandomSamplingBatch(IntPtr input, int max_length, float temperature)
        {
            return Interop.onnx_cond_gen_generate_random_sampling_batch(_context, input, max_length, temperature);
        }

        public SliceUseAsciiStringPattern GenerateArgmaxBatch(IntPtr input, int max_length)
        {
            return Interop.onnx_cond_gen_generate_argmax_batch(_context, input, max_length);
        }

        public IntPtr Context => _context;
    }


    public partial class ConditionalGenerationPipelineWithPKVs : IDisposable
    {
        private IntPtr _context;

        private ConditionalGenerationPipelineWithPKVs() {}

        public static ConditionalGenerationPipelineWithPKVs FromPretrained(IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new ConditionalGenerationPipelineWithPKVs();
            var rval = Interop.onnx_cond_gen_pkvs_from_pretrained(ref self._context, env, model_id, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static ConditionalGenerationPipelineWithPKVs CreateFromMemory(IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new ConditionalGenerationPipelineWithPKVs();
            var rval = Interop.onnx_cond_gen_pkvs_create_from_memory(ref self._context, env, model, tokenizer_config, special_tokens_map, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static ConditionalGenerationPipelineWithPKVs CreateFromPaths(IntPtr env, string model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new ConditionalGenerationPipelineWithPKVs();
            var rval = Interop.onnx_cond_gen_pkvs_create_from_paths(ref self._context, env, model, tokenizer_config, special_tokens_map, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_cond_gen_pkvs_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public string GenerateTopkSampling(string input, int max_length, int topk, float temperature)
        {
            var s = Interop.onnx_cond_gen_pkvs_generate_topk_sampling(_context, input, max_length, topk, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateRandomSampling(string input, int max_length, float temperature)
        {
            var s = Interop.onnx_cond_gen_pkvs_generate_random_sampling(_context, input, max_length, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateArgmax(string input, int max_length)
        {
            var s = Interop.onnx_cond_gen_pkvs_generate_argmax(_context, input, max_length);
            return Marshal.PtrToStringAnsi(s);
        }

        public SliceUseAsciiStringPattern GenerateTopkSamplingBatch(IntPtr input, int max_length, int topk, float temperature)
        {
            return Interop.onnx_cond_gen_pkvs_generate_topk_sampling_batch(_context, input, max_length, topk, temperature);
        }

        public SliceUseAsciiStringPattern GenerateRandomSamplingBatch(IntPtr input, int max_length, float temperature)
        {
            return Interop.onnx_cond_gen_pkvs_generate_random_sampling_batch(_context, input, max_length, temperature);
        }

        public SliceUseAsciiStringPattern GenerateArgmaxBatch(IntPtr input, int max_length)
        {
            return Interop.onnx_cond_gen_pkvs_generate_argmax_batch(_context, input, max_length);
        }

        public IntPtr Context => _context;
    }


    public partial class EmbeddingPipeline : IDisposable
    {
        private IntPtr _context;

        private EmbeddingPipeline() {}

        public static EmbeddingPipeline FromPretrained(IntPtr env, string model_id, PoolingStrategyFFI pooling_strategy, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new EmbeddingPipeline();
            var rval = Interop.onnx_emb_from_pretrained(ref self._context, env, model_id, pooling_strategy, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static EmbeddingPipeline CreateFromMemory(IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, PoolingStrategyFFI pooling_strategy, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new EmbeddingPipeline();
            var rval = Interop.onnx_emb_create_from_memory(ref self._context, env, model, tokenizer_config, special_tokens_map, pooling_strategy, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static EmbeddingPipeline CreateFromFiles(IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, PoolingStrategyFFI pooling_strategy, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new EmbeddingPipeline();
            var rval = Interop.onnx_emb_create_from_files(ref self._context, env, model_path, tokenizer_config_path, special_tokens_map_path, pooling_strategy, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_emb_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public EmbeddingFFI Embed(string input)
        {
            return Interop.onnx_emb_embed(_context, input);
        }

        public SliceEmbeddingFFI EmbedBatch(IntPtr input)
        {
            return Interop.onnx_emb_embed_batch(_context, input);
        }

        public IntPtr Context => _context;
    }


    public partial class SequenceClassificationPipeline : IDisposable
    {
        private IntPtr _context;

        private SequenceClassificationPipeline() {}

        public static SequenceClassificationPipeline FromPretrained(IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new SequenceClassificationPipeline();
            var rval = Interop.onnx_classification_from_pretrained(ref self._context, env, model_id, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static SequenceClassificationPipeline CreateFromMemory(IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new SequenceClassificationPipeline();
            var rval = Interop.onnx_classification_create_from_memory(ref self._context, env, model, tokenizer_config, special_tokens_map, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static SequenceClassificationPipeline CreateFromFiles(IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new SequenceClassificationPipeline();
            var rval = Interop.onnx_classification_create_from_files(ref self._context, env, model_path, tokenizer_config_path, special_tokens_map_path, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_classification_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public PredictionFFI Classify(string input)
        {
            return Interop.onnx_classification_classify(_context, input);
        }

        public SlicePredictionFFI ClassifyBatch(IntPtr input)
        {
            return Interop.onnx_classification_classify_batch(_context, input);
        }

        public IntPtr Context => _context;
    }


    public partial class TokenClassificationPipeline : IDisposable
    {
        private IntPtr _context;

        private TokenClassificationPipeline() {}

        public static TokenClassificationPipeline FromPretrained(IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new TokenClassificationPipeline();
            var rval = Interop.onnx_token_classification_from_pretrained(ref self._context, env, model_id, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static TokenClassificationPipeline CreateFromMemory(IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new TokenClassificationPipeline();
            var rval = Interop.onnx_token_classification_create_from_memory(ref self._context, env, model, tokenizer_config, special_tokens_map, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static TokenClassificationPipeline CreateFromFiles(IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new TokenClassificationPipeline();
            var rval = Interop.onnx_token_classification_create_from_files(ref self._context, env, model_path, tokenizer_config_path, special_tokens_map_path, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_token_classification_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public TaggedStringFFI Tag(string input)
        {
            return Interop.onnx_token_classification_tag(_context, input);
        }

        public SliceTaggedStringFFI TagBatch(IntPtr input)
        {
            return Interop.onnx_token_classification_tag_batch(_context, input);
        }

        public IntPtr Context => _context;
    }


    public partial class OptimumSeq2SeqPipeline : IDisposable
    {
        private IntPtr _context;

        private OptimumSeq2SeqPipeline() {}

        public static OptimumSeq2SeqPipeline FromPretrained(IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new OptimumSeq2SeqPipeline();
            var rval = Interop.onnx_optimum_seq2seq_from_pretrained(ref self._context, env, model_id, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static OptimumSeq2SeqPipeline CreateFromMemory(IntPtr env, Sliceu8 encoder_model, Sliceu8 decoder_model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new OptimumSeq2SeqPipeline();
            var rval = Interop.onnx_optimum_seq2seq_create_from_memory(ref self._context, env, encoder_model, decoder_model, tokenizer_config, special_tokens_map, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static OptimumSeq2SeqPipeline CreateFromFiles(IntPtr env, string encoder_model_path, string decoder_model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new OptimumSeq2SeqPipeline();
            var rval = Interop.onnx_optimum_seq2seq_create_from_files(ref self._context, env, encoder_model_path, decoder_model_path, tokenizer_config_path, special_tokens_map_path, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_optimum_seq2seq_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public string GenerateTopkSampling(string input, Option*const i8 decoder_input, int max_length, int topk, float temperature)
        {
            var s = Interop.onnx_optimum_seq2seq_generate_topk_sampling(_context, input, decoder_input, max_length, topk, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateRandomSampling(string input, Option*const i8 decoder_input, int max_length, float temperature)
        {
            var s = Interop.onnx_optimum_seq2seq_generate_random_sampling(_context, input, decoder_input, max_length, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateArgmax(string input, Option*const i8 decoder_input, int max_length)
        {
            var s = Interop.onnx_optimum_seq2seq_generate_argmax(_context, input, decoder_input, max_length);
            return Marshal.PtrToStringAnsi(s);
        }

        public SliceUseAsciiStringPattern GenerateTopkSamplingBatch(IntPtr input, OptionStringBatch decoder_input, int max_length, int topk, float temperature)
        {
            return Interop.onnx_optimum_seq2seq_generate_topk_sampling_batch(_context, input, decoder_input, max_length, topk, temperature);
        }

        public SliceUseAsciiStringPattern GenerateRandomSamplingBatch(IntPtr input, OptionStringBatch decoder_input, int max_length, float temperature)
        {
            return Interop.onnx_optimum_seq2seq_generate_random_sampling_batch(_context, input, decoder_input, max_length, temperature);
        }

        public SliceUseAsciiStringPattern GenerateArgmaxBatch(IntPtr input, OptionStringBatch decoder_input, int max_length)
        {
            return Interop.onnx_optimum_seq2seq_generate_argmax_batch(_context, input, decoder_input, max_length);
        }

        public IntPtr Context => _context;
    }


    public partial class OptimumSeq2SeqPipelineWithPKVs : IDisposable
    {
        private IntPtr _context;

        private OptimumSeq2SeqPipelineWithPKVs() {}

        public static OptimumSeq2SeqPipelineWithPKVs FromPretrained(IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new OptimumSeq2SeqPipelineWithPKVs();
            var rval = Interop.onnx_optimum_seq2seq_pkvs_from_pretrained(ref self._context, env, model_id, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static OptimumSeq2SeqPipelineWithPKVs CreateFromMemory(IntPtr env, Sliceu8 encoder_model, Sliceu8 decoder_model, Sliceu8 decoder_model_pkvs, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization_level)
        {
            var self = new OptimumSeq2SeqPipelineWithPKVs();
            var rval = Interop.onnx_optimum_seq2seq_pkvs_create_from_memory(ref self._context, env, encoder_model, decoder_model, decoder_model_pkvs, tokenizer_config, special_tokens_map, device, optimization_level);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static OptimumSeq2SeqPipelineWithPKVs CreateFromFiles(IntPtr env, string encoder_model_path, string decoder_model_path, string decoder_model_pkvs_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization_level)
        {
            var self = new OptimumSeq2SeqPipelineWithPKVs();
            var rval = Interop.onnx_optimum_seq2seq_pkvs_create_from_files(ref self._context, env, encoder_model_path, decoder_model_path, decoder_model_pkvs_path, tokenizer_config_path, special_tokens_map_path, device, optimization_level);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_optimum_seq2seq_pkvs_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public string GenerateTopkSampling(string input, Option*const i8 decoder_input, int max_length, int topk, float temperature)
        {
            var s = Interop.onnx_optimum_seq2seq_pkvs_generate_topk_sampling(_context, input, decoder_input, max_length, topk, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateRandomSampling(string input, Option*const i8 decoder_input, int max_length, float temperature)
        {
            var s = Interop.onnx_optimum_seq2seq_pkvs_generate_random_sampling(_context, input, decoder_input, max_length, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateArgmax(string input, Option*const i8 decoder_input, int max_length)
        {
            var s = Interop.onnx_optimum_seq2seq_pkvs_generate_argmax(_context, input, decoder_input, max_length);
            return Marshal.PtrToStringAnsi(s);
        }

        public SliceUseAsciiStringPattern GenerateTopkSamplingBatch(IntPtr input, OptionStringBatch decoder_input, int max_length, int topk, float temperature)
        {
            return Interop.onnx_optimum_seq2seq_pkvs_generate_topk_sampling_batch(_context, input, decoder_input, max_length, topk, temperature);
        }

        public SliceUseAsciiStringPattern GenerateRandomSamplingBatch(IntPtr input, OptionStringBatch decoder_input, int max_length, float temperature)
        {
            return Interop.onnx_optimum_seq2seq_pkvs_generate_random_sampling_batch(_context, input, decoder_input, max_length, temperature);
        }

        public SliceUseAsciiStringPattern GenerateArgmaxBatch(IntPtr input, OptionStringBatch decoder_input, int max_length)
        {
            return Interop.onnx_optimum_seq2seq_pkvs_generate_argmax_batch(_context, input, decoder_input, max_length);
        }

        public IntPtr Context => _context;
    }


    public partial class Seq2SeqGenerationPipeline : IDisposable
    {
        private IntPtr _context;

        private Seq2SeqGenerationPipeline() {}

        public static Seq2SeqGenerationPipeline FromPretrained(IntPtr env, string model_id, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new Seq2SeqGenerationPipeline();
            var rval = Interop.onnx_seq2seq_from_pretrained(ref self._context, env, model_id, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static Seq2SeqGenerationPipeline CreateFromMemory(IntPtr env, Sliceu8 model, string tokenizer_config, string special_tokens_map, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new Seq2SeqGenerationPipeline();
            var rval = Interop.onnx_seq2seq_create_from_memory(ref self._context, env, model, tokenizer_config, special_tokens_map, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static Seq2SeqGenerationPipeline CreateFromFiles(IntPtr env, string model_path, string tokenizer_config_path, string special_tokens_map_path, DeviceFFI device, GraphOptimizationLevelFFI optimization)
        {
            var self = new Seq2SeqGenerationPipeline();
            var rval = Interop.onnx_seq2seq_create_from_files(ref self._context, env, model_path, tokenizer_config_path, special_tokens_map_path, device, optimization);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = Interop.onnx_seq2seq_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public string GenerateTopkSampling(string input, Option*const i8 decoder_input, int max_length, int topk, float temperature)
        {
            var s = Interop.onnx_seq2seq_generate_topk_sampling(_context, input, decoder_input, max_length, topk, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateRandomSampling(string input, Option*const i8 decoder_input, int max_length, float temperature)
        {
            var s = Interop.onnx_seq2seq_generate_random_sampling(_context, input, decoder_input, max_length, temperature);
            return Marshal.PtrToStringAnsi(s);
        }

        public string GenerateArgmax(string input, Option*const i8 decoder_input, int max_length)
        {
            var s = Interop.onnx_seq2seq_generate_argmax(_context, input, decoder_input, max_length);
            return Marshal.PtrToStringAnsi(s);
        }

        public SliceUseAsciiStringPattern GenerateTopkSamplingBatch(IntPtr input, OptionStringBatch decoder_input, int max_length, int topk, float temperature)
        {
            return Interop.onnx_seq2seq_generate_topk_sampling_batch(_context, input, decoder_input, max_length, topk, temperature);
        }

        public SliceUseAsciiStringPattern GenerateRandomSamplingBatch(IntPtr input, OptionStringBatch decoder_input, int max_length, float temperature)
        {
            return Interop.onnx_seq2seq_generate_random_sampling_batch(_context, input, decoder_input, max_length, temperature);
        }

        public SliceUseAsciiStringPattern GenerateArgmaxBatch(IntPtr input, OptionStringBatch decoder_input, int max_length)
        {
            return Interop.onnx_seq2seq_generate_argmax_batch(_context, input, decoder_input, max_length);
        }

        public IntPtr Context => _context;
    }



    public class InteropException<T> : Exception
    {
        public T Error { get; private set; }

        public InteropException(T error): base($"Something went wrong: {error}")
        {
            Error = error;
        }
    }

}
